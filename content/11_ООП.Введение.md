# ООП 1 . Введение.

![фвыа](http://images.na4u.ru/static/oop/1.jpg)

**Какие проблемы решает ООП**

**Объектно-ориентированное программирование (ООП)** — это способ организации кода, при котором программа состоит из **объектов**.  

Объектно-ориентированный стиль программирования помогает писать код, который проще **поддерживать**, **расширять** и **масштабировать**. Это особенно важно для долгоживущих и сложных систем.

ООП в основном влияет на _нефункциональные требования_ в разработке:

- **Сопровождаемость** (легче читать, модифицировать и тестировать код)
- **Расширяемость** (добавление новых функций без значительных изменений существующего кода)
- **Масштабируемость** (структура кода позволяет распределять работу между командами и модулями)
- **Читаемость и повторное использование кода**

ООП влияет на **форму** кода
### Какие формы мы уже прошли

- **Императивное программирование** 
	- Просто пишем последовательность инструкций 
- **Процедурное (используем функции)**
	- Можно переиспользовать код много раз
	- Внутри функции есть свои переменные, видимые только внутри нее

Что делать, когда функций много? Когда они относятся к разным темам? 

- **Объектно-ориентированное программирование (ООП)**



![фвыа](http://images.na4u.ru/static/oop/2.jpg)
**Пример калькулятора в функциональном стиле** 

```python

def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def multiply(a, b):
    return a * b

def divide(a, b):
    return a / b
```

**Пример калькулятора в ООП стиле** 

```python
class Calculator:
	def __init__(self):
		self.operations = 0 
		
    def add(self, a, b):
	    self.operations += 1
        return a + b

    def subtract(self, a, b):
	    self.operations += 1
        return a - b

    def multiply(self, a, b):
        self.operations += 1
        return a * b

    def divide(self, a, b):
        self.operations += 1
        return a / b


# Пример использования
calc = Calculator()

print(calc.add(10, 5))       # 15
print(calc.subtract(10, 5))  # 5
print(calc.multiply(10, 5))  # 50
print(calc.divide(10, 5))    # 2.0
```


### Основные термины ООП

- **Класс `Calculator`** — шаблон, описывающий поведение калькулятора.
- **calc** - объект, экземпляр класса **Calculator**
- **Методы** (`add`, `subtract`, `multiply`, `divide`, `clear`) — реализуют действия. Это аналоги функций. 
- **Атрибут** **operations** хранит в себе количество операций

**Класс** — это шаблон или чертеж, из которого создаются объекты. Он описывает общие характеристики и поведение объектов.

**Объект** — это экземпляр класса, содержащий конкретные значения атрибутов и методы для взаимодействия с этими значениями.

**Атрибут** — это переменная, определенная в классе, которая хранит данные, связанные с объектом.

**Метод** — это функция, определенная внутри класса, которая описывает поведение объектов класса.

**Инкапсуляция** — принцип, объединяющий данные и методы, работающие с этими данными, в одном объекте, и скрывающий детали реализации от пользователя.


## Что такое self? 

- `self` — это **ссылка на текущий экземпляр (объект) класса**.
- Он нужен, чтобы внутри методов класса обращаться к **атрибутам и другим методам именно этого объекта**.
- В методах класса `self` **обязательно указывается первым параметром**.

Другими словами self - это как глобальная переменная для всего класса. Через нее можно обращаться к атрибутам, методам. Это связующее звено. 

В примере с калькулятором, используя атрибут **self.operations** мы можем хранить и изменять количество операций, которое было произведено.  

### Что такое `__init__`?

- `__init__` — это **специальный метод** (конструктор) класса в Python.
- Его название всегда именно такое: две подчёркивания до и после — `__init__`.
- Он автоматически вызывается **при создании нового объекта** этого класса.
    
#### Для чего нужен метод `__init__`?

- Основная задача метода `__init__` — **инициализация нового объекта**.
- Он позволяет задать **начальное состояние** объекта: присвоить значения его атрибутам.
- Это аналог конструктора в других языках программирования.

При создании нового объекта, сначала вызывается метод init (если он есть). Метод init может иметь или не иметь аргументы.

В примере с калькулятором, в методе **init** ничего не передавалось, но внутри было создано начальное значение атрибута **operations** 

```python
class Calculator:
	def __init__(self):
		self.operations = 0 
		```

### Образное объяснение ООП 

![фвыа](http://images.na4u.ru/static/oop/3.jpg)


```python
class Cat:
    def __init__(self, name, age, color):
        self.name = name      # имя кота
        self.age = age        # возраст
        self.color = color    # цвет шерсти
        self.mood = 10

    def meow(self):
        return f"{self.name} говорит: Мяу!"

    def sleep(self):
	    print('Ура спать!')
		self.mood += 5

    def describe(self):
        return f"Кот по имени {self.name}, возраст {self.age} года(лет), цвет шерсти {self.color}."


# Пример использования

my_cat = Cat("Барсик", 3, "серый")
print(my_cat.meow())          
print(my_cat.describe())   
print(my_cat.sleep())    
```


Заметьте, что в этом примере при создании нового объекта мы передавали аргументы: имя, возраст и цвет. Это произошло, потому что эти аргументы были определены в методе __init__

То есть в случае, если мы хотим сразу же наделить объект свойствами по умолчанию -- надо задавать аргументы в методе init. 
