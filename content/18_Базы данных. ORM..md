## Базы данных. ORM.

При работе с базой данных хочется меньше думать о синтаксисе sql запросов, больше о бизнес-логике. Существуют инструменты, которые позволяют это сделать. 

ORM(Object-Relational Mapping) - объектно-реляционное отображение. Эта технология связывает объектно-ориентированное программирование и с базами данных.

Библиотеки, реализующие ORM позволяют работать с базой данных, как с обычным ООП классом в питоне. 

**Преимущества ORM:**

- Работа с БД через объекты, а не через SQL.
- Переносимость кода между СУБД.
- Автоматическая генерация SQL-запросов.
- Меньше шансов на SQL-инъекции.

## SQLAlchemy — популярная ORM для Python

Существует несколько библиотек, реализующих ORM в Python. Самой популярной считается sqlalchemy. Немного измененная ее версия будет использоваться в Django. 

Каждая библиотека определяет свой синтаксис создания аналогов таблиц с помощью кода.
Ниже приведен пример описания таблицы **User** с несколькими полями. 

```python
from sqlalchemy import Column, Integer, String, create_engine
from sqlalchemy.orm import declarative_base, sessionmaker

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)
    age = Column(Integer)

    def __repr__(self):
        return f"<User(id={self.id}, name='{self.name}', age={self.age})>"
```

- Создается класс - с наследованием от базового класса **Base**
- Атрибут класса __ tablename __ хранит название таблицы в базе
- Атрибуты класса по названию, совпадающие с названиями полей в таблице
	- Значения атрибутов - описание свойств поля 
- Метод __ repr __ - какое название будет у каждой записи таблицы. Будет видно при использовании print() 

Если все описано верно -- можно подключиться к базе данных и выполнять запросы, используя класс User в качестве прослойки. 
![фвыа](http://images.na4u.ru/static/orm/2.jpg)


## Выполнение запросов из SQLAlchemy


### Получение данных

```python

# Подключение к SQLite
engine = create_engine("sqlite:///users.db", echo=True)
# Создание таблиц
Base.metadata.create_all(engine)
# Фабрика для сессий
Session = sessionmaker(bind=engine, future=True)

with Session() as session:
    # Все пользователи
    users = session.query(User).all()
    print("Все пользователи:", users)

    # Фильтрация
    alice = session.query(User).filter_by(name="Alice").first()
    print("Alice:", alice)
```

1. Создание подключения 
	1. Можно передать подключения для разных СУБД. Например, PostgreSQL, MSSQL
2. Cоздание таблиц
3. Создание фабрики для сессий 
	1. Класс, с помощью которого можно будет открывать соединения
4. Выполнение запроса в контекстном менеджере. Он сам открывает соединение. Коммит автоматически не выполняет. 
### Запись данных 

```python
with Session() as session:
    user1 = User(name="Alice", age=25)
    user2 = User(name="Bob", age=30)
    session.add_all([user1, user2])
    session.commit()   # фиксируем изменения
```

## Удаление данных

```python
with Session() as session:
    user = session.query(User).filter_by(name="Alice").first()
    if user:
        session.delete(user)
        session.commit()
```


## Новый синтаксис описания таблиц

В версии 2.0 библиотеки sqlalchemy появился другой способ описания таблиц. Используя type hints. 

```python
from typing import Optional, List
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy import String

class User(Base):
    __tablename__ = "user_account"

    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(30))
    fullname: Mapped[Optional[str]]

    addresses: Mapped[List["Address"]] = relationship(
        back_populates="user",
        cascade="all, delete-orphan"
    )

    def __repr__(self) -> str:
        return f"User(id={self.id!r}, name={self.name!r}, fullname={self.fullname!r})"
```

Лучше использовать его, так как старый синтаксис однажды станет недоступным, но для обучения старый вариант мне кажется более понятным. 


## Cвязь двух таблиц в sqlalchemy

Как работать с таблицами, которые связаны в базе по ключу. 


```python
from sqlalchemy import Column, Integer, String, ForeignKey, create_engine
from sqlalchemy.orm import declarative_base, relationship, sessionmaker

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String(50), nullable=False)

    # Связь "один-ко-многим" (у пользователя может быть несколько адресов)
    addresses = relationship("Address", back_populates="user")

    def __repr__(self):
        return f"<User(id={self.id}, name={self.name})>"


class Address(Base):
    __tablename__ = "addresses"

    id = Column(Integer, primary_key=True, autoincrement=True)
    email = Column(String(100), nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"))

    # Обратная связь (каждый адрес связан с конкретным пользователем)
    user = relationship("User", back_populates="addresses")

    def __repr__(self):
        return f"<Address(id={self.id}, email={self.email})>"
```

Обратите внимание на параметр **back_populates** - это имя, по которому можно получать связанные данные. 

Например
- получить все адреса конкретного пользователя
- получить пользователя, которому принадлежит конкретный адрес

### Все пользователи и их адреса

```python
users = session.query(User).all()
for u in users:
    print(u.name, "->")
    for address in u.addresses:
	    print(address.email)
    
```

### Фильтрация по адресу

```python
addr = session.query(Address).filter_by(email="alice@work.com").first()
print(addr.email, "принадлежит пользователю", addr.user.name)
```

