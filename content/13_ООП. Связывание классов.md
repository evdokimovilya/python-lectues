# ООП 2. Связывание классов. 

## Связь нескольких классов. 

ООП стиль программирования позволяет нам описывать программу в виде взаимодействия нескольких классов друг с другом. Каждый класс отвечают за свою зону ответственности. 

Если мы правильно распределим роли и свяжем классы между собой в нужных местах - получим программу, которую удобно масштабировать, читать. 

### Варианты связи классов

Два популярных способа связать классы друг с другом: 
- **Наследование** – один класс расширяет другой, получая его свойства и методы.
- **Отношение "часть - целое" (композиция/агрегация)** – один класс полностью управляет жизненным циклом другого объекта

## Отношение "часть - целое"

### 1. Агрегация (часть может существовать отдельно)

- Используем, когда **часть может существовать отдельно** и «владелец» лишь использует её.
    
- Примеры:
    - Калькулятор и  Логгер.
    - Университет и Преподаватель.
    - Команда и Игрок.
- Когда нужно **разделение ответственности**, или один компонент используется в нескольких объектах.

![фвыа](http://images.na4u.ru/static/oop2/1.png)
![фвыа](http://images.na4u.ru/static/oop2/2.png)
```python
class Logger():
    def __init__(self, filename):
        self.filename = filename

    def log(self, number_1, number_2, res, action):
        """Запись действий в файл"""
        if os.path.exists(self.filename ):
            open_mode = 'a'
        else:
            open_mode = 'w'
        with open(self.filename, open_mode, encoding='utf-8') as f:
            data = f'{datetime.now()}: {number_1} {action} {number_2} = {res}\n'
            f.write(data)


class Calc():

    def __init__(self, logger):
        # привязываем логгер
        self.logger = logger
    def add(self, number_1, number_2):
        res = number_1 + number_2
        print(res)
        self.logger.log(number_1, number_2, res, 'сложение')

    def subtract(self, number_1, number_2):
        res = number_1 - number_2
        print(res)
        self.logger.log(number_1, number_2, res, 'вычитание')
        
        
logger = Logger('log.txt') # создание экземпляра класса Логгер
calc2 = Calc(logger) # передаем логгер калькулятору

calc.add(3, 4)
calc.subtract(3, 4)
```



### 2. Композиция (часть полностью зависит от целого)

- Используем, когда **часть не может существовать отдельно**.

Примеры 
- Ученик и Школа. Ученик существует только в контексте класса Школы. 
![фвыа](http://images.na4u.ru/static/oop2/3.png)
```python
class Student:

    def __init__(self, name):

        self.name = name
        self.grades = []

    def __str__(self):

        return f"{self.name}, оценки: {self.grades}"

class School:

    def __init__(self):
        self.students = []

    def enroll_student(self, student: Student):

        self.students.append(student)
        print(f"{student.name} зачислен в школу.")

    def show_students(self):

        print("Студенты школы:")
        for student in self.students:
            print(f" - {student}")

school = School()
alice = Student("Алиса")
bob = Student("Боб")


school.enroll_student(alice)
school.enroll_student(bob)

school.show_students()
```

## Наследование

Наследование - один из основных принципов ООП. Применяется, когда мы хотим расширить или изменить функционал родительского класса. 

Например, мы хотим иметь две версии калькулятора. 
- Простая - с простыми мат.операциями 
- Улучшенная - есть еще метод для нахождения процента от числа 

Чтобы избежать дублирования кода при создании улучшенного калькулятора, мы можем унаследовать всю базовую логику обычного калькулятора и дополнить ее. 

![фвыа](http://images.na4u.ru/static/oop2/4.png)
```python
class Calc():

    def __init__(self, logger):
        # привязываем логгер
        self.logger = logger
    def add(self, number_1, number_2):
        res = number_1 + number_2
        print(res)
        self.logger.log(number_1, number_2, res, 'сложение')

    def subtract(self, number_1, number_2):
        res = number_1 - number_2
        print(res)
        self.logger.log(number_1, number_2, res, 'вычитание')


class SuperCalc(Calc):

    def find_percent(self, number, percent):
        res = number * percent/100
        print(res)
        self.logger.log(number, percent, res, 'проценты')

```

