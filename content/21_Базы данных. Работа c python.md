## Базы данных. Работа c python.
## Базы данных. Работа c python.


Пример взаимодействия с базой данных из питона 

```python
import sqlite3

# 1. Подключаемся к базе (создаст файл, если его нет)
conn = sqlite3.connect("example.db")
cur = conn.cursor()

# 2. Создаём таблицу (если нет)
cur.execute("CREATE TABLE IF NOT EXISTS users (name TEXT, age INTEGER)")

# 3. Записываем данные
cur.execute("INSERT INTO users (name, age) VALUES (?, ?)", ("Alice", 25))

# 4. Сохраняем изменения
conn.commit()

# 5. Закрываем соединение
conn.close()
```

### Connection (Cоединение)

Соединение — это канал связи между вашей программой и базой данных.  
Через него Python отправляет SQL-запросы и получает ответы.

**Что делает соединение:**

- Устанавливает «сессию» с СУБД.
- Контролирует **транзакции** (группы изменений).
- Управляет ресурсами (закрывает соединение, если оно больше не нужно).

####  В случае **SQLite**

- База данных хранится в одном локальном файле (`.db` или `.sqlite`).
- Соединение — это по сути доступ к этому файлу.
- Python-модуль: `sqlite3` (входит в стандартную библиотеку).

#### В случае **PostgreSQL**

- Это серверная СУБД: база живёт в отдельном процессе (часто на другом компьютере).
    
- Чтобы подключиться, нужны:
    - адрес сервера (`host`);
    - порт (`5432` по умолчанию);
    - имя пользователя;
    - пароль;
    - имя базы данных.

### Cursor (Курсор)

Курсор — это специальный объект, который создаётся на основе соединения и служит «инструментом» для работы с SQL-запросами.

Можно представить так:

- **Соединение** — это канал связи с базой.
- **Курсор** — это «оператор на линии», которому вы даёте команды в рамках этого канала.
    
В разных СУБД курсор может существовать и на стороне клиента (Python), и на стороне сервера (PostgreSQL, MySQL), в зависимости от типа операции.

Все операции с базой происходят через создание курсора. 

### Transaction (Транзакция)

Транзакция — это **последовательность операций с базой данных**, которая выполняется как единое целое.  

Основной принцип: _либо все операции выполняются успешно, либо база данных возвращается в исходное состояние_.

В Python через DB API 2.0 (PEP 249) транзакция начинается **автоматически** при первом изменяющем запросе (`INSERT`, `UPDATE`, `DELETE`).
    
Она продолжается, пока вы:
    - не сделаете `commit()` — зафиксировать изменения; 
    - или `rollback()` — откатить изменения.
        
- По умолчанию **автоматического commit нет** (кроме некоторых драйверов с autocommit-режимом).

```python
conn = sqlite3.connect("example.db")
cur1 = conn.cursor()
cur2 = conn.cursor()

cur1.execute("INSERT INTO users (name) VALUES (?)", ("Alice",))
cur2.execute("INSERT INTO users (name) VALUES (?)", ("Bob",))

# Пока не commit — данные не видны другим соединениям
conn.commit()  # Сохраняет обе вставки

conn.close()
```

## Использование контекстных менеджеров

Библиотеки для работы с бд обычно позволяют выполнять запросы внутри контекстных менеджеров. 

В этом случае открытие соединения, коммит запросов, закрытие соединения происходят автоматически. 

```python
with sqlite3.connect("example.db") as conn:
    cur = conn.cursor()
    cur.execute("INSERT INTO users (name, age) VALUES (?, ?)", ("Bob", 30))
    cur.execute("INSERT INTO users (name, age) VALUES (?, ?)", ("Charlie", 22))
# commit — автоматическийv
```


## Чтение данных 

### Паттерн 1 — забрать всё разом - список кортежей 

```python
with sqlite3.connect("example.db") as conn:
    cur = conn.cursor()
    cur.execute("SELECT * FROM users")
    rows = cur.fetchall()  # список кортежей
    for row in rows:
        print(row)
```

### Паттерн 2 — забрать всё разом - список словарей

```python
conn = sqlite3.connect("example.db")
conn.row_factory = sqlite3.Row  # каждая строка как словарь
cur = conn.cursor()
cur.execute("SELECT * FROM users")

for row in cur:
    print(dict(row))  # {'name': 'Alice', 'age': 25}
    
conn.close()
```

### Паттерн 3 - итерация по курсору

```python
with sqlite3.connect("example.db") as conn:
    cur = conn.cursor()
    cur.execute("SELECT * FROM users")
    for row in cur:  # курсор сам подаёт строки
        print(row)
```

Особенность в том, что при большом количестве строк этот способ будет работать так же быстро, поскольку он не подгружает все данные заранее. 



