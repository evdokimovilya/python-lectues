# ООП 4. Абстрактные классы. 

Абстрактный класс — это **класс, который не предназначен для создания экземпляров напрямую**.  

Он задаёт **интерфейс** (методы), который должны реализовать все подклассы.

Иными словами:

- Абстрактный класс говорит: “Любой класс, который наследует меня, **обязательно должен реализовать эти методы**”.
- При этом сам абстрактный класс может содержать обычные методы и атрибуты.

В Python для этого используется модуль `abc` (Abstract Base Classes).

```python
from abc import ABC, abstractmethod

class Animal(ABC):  # наследуемся от ABC → абстрактный класс
    @abstractmethod
    def speak(self):
        pass  # метод, который должен реализовать подкласс

    def sleep(self):
        print("zzz...")  # обычный метод, подклассы могут его использовать
```


В предыдущей главе мы рассматривали паттерн MVC. 
Для компонента view было реализовано два класса: BasicView, RichView
Мы сами контролировали, чтобы они обладали методами с одним и тем же названием. 
Но так можно легко ошибиться. Тем более другие разработчики, которые захотят потом изменить программу точно могут не обратить на это внимание. 

Абстрактные классы как решают такую проблему. Мы можем создать абстрактный класс компонента View и указать там, какие методы должны реализовывать все наследники этого класса. 

```python

class AbstractView(ABC):
    @abstractmethod
    def show_notes(self, notes):
        pass

    @abstractmethod
    def show_message(self, message):
        pass
        


class BasicView(AbstractView):
    def show_notes(self, notes):
        if not notes:
            print("Нет заметок.")
        for i, note in enumerate(notes, 1):
            print(f"{i}. {note['title']}\n   {note['content']}")

    def show_message(self, message):
        print(message)


class RichView(AbstractView):
    def __init__(self):
        self.console = Console()

    def show_notes(self, notes):
        if not notes:
            self.console.print("[bold red]Нет заметок[/bold red]")
            return
        table = Table(title="Заметки")
        table.add_column("№", style="cyan")
        table.add_column("Заголовок", style="green")
        table.add_column("Содержание", style="yellow")
        for i, note in enumerate(notes, 1):
            table.add_row(str(i), note["title"], note["content"])
        self.console.print(table)

    def show_message(self, message):
        self.console.print(f"[bold blue]{message}[/bold blue]")

```

Теперь мы не сможем не реализовать в классе метод show_notes, если укажем наследование от абстрактного класса. 

